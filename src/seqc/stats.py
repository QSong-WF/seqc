import numpy as npimport pandas as pdimport multiprocessingfrom sklearn.neighbors import NearestNeighborsdef correlation_map(x, y):    """Correlate each n with each m.    Parameters    ----------    x : np.array      Shape N X T.    y : np.array      Shape M X T.    Returns    -------    np.array      N X M array in which each element is a correlation coefficient.    """    mu_x = x.mean(1)    mu_y = y.mean(1)    n = x.shape[1]    if n != y.shape[1]:        raise ValueError('x and y must ' +                         'have the same number of timepoints.')    s_x = x.std(1, ddof=n - 1)    s_y = y.std(1, ddof=n - 1)    cov = np.dot(x,                 y.T) - n * np.dot(mu_x[:, np.newaxis],                                   mu_y[np.newaxis, :])    return cov / np.dot(s_x[:, np.newaxis], s_y[np.newaxis, :])class smoothing:    @staticmethod    def kneighbors(data, n_neighbors=50):        """        :param data: np.ndarray | pd.DataFrame; genes x cells array        :param n_neighbors: int; number of neighbors to smooth over        :return: np.ndarray | pd.DataFrame; same as input        """        if isinstance(data, pd.DataFrame):            df = True            data_ = data.values        elif isinstance(data, np.ndarray):            df = False            data_ = data        else:            raise TypeError("data must be a pd.DataFrame or np.ndarray")        knn = NearestNeighbors(            n_neighbors=n_neighbors,            n_jobs=multiprocessing.cpu_count() - 1)        knn.fit(data_)        dist, inds = knn.kneighbors(data_)        # set values equal to their means across neighbors        res = data_[inds, :].mean(axis=1)        if df:            res = pd.DataFrame(res, index=data.index,                               columns=data.columns)        return res