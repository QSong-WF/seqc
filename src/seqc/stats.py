import numpy as npimport pandas as pdimport multiprocessingfrom statsmodels.stats.anova import anova_lmfrom scipy.stats import fdef correlation_map(x, y):    """Correlate each n with each m.    Parameters    ----------    x : np.array      Shape N X T.    y : np.array      Shape M X T.    Returns    -------    np.array      N X M array in which each element is a correlation coefficient.    """    mu_x = x.mean(1)    mu_y = y.mean(1)    n = x.shape[1]    if n != y.shape[1]:        raise ValueError('x and y must ' +                         'have the same number of timepoints.')    s_x = x.std(1, ddof=n - 1)    s_y = y.std(1, ddof=n - 1)    cov = np.dot(x,                 y.T) - n * np.dot(mu_x[:, np.newaxis],                                   mu_y[np.newaxis, :])    return cov / np.dot(s_x[:, np.newaxis], s_y[np.newaxis, :])class KNeighborsSmoothing:    @staticmethod    def obs_filter(x, t):        """        :param x: data to be filtered        :param t: minimum number of observations per feature        """    @staticmethod    def smooth(x, nbrs, data, alpha):        """        input:            alpha: the smoothing factor            nbrs: trained NearestNeighbors from sklearn            data: the original data                 (since NearestNeighbors returns only the index and not the samples)            x:    what we want to smooth        output:            smoothed x with its nearest neighbours        """        distances, indices = nbrs.kneighbors(x)        distances = list(map(lambda z: abs(-z + 1), distances)[0])        norm = sum(distances)        if norm == 0:            "No neighbours were found."            return x        distances = list(map(lambda z: (1 - alpha) * z / norm, distances))        indices = list(map(lambda z: data[z], indices)[0])        other = np.array([indices[i] * distances[i] for i in range(len(distances))])        z = x * alpha        z = z.reshape((1, z.shape[0]))        smoothed = sum(np.concatenate((other, z), axis=0))        return smoothedclass NonParametricUnbalanced2WayANOVA:    def __init__(self, data: pd.DataFrame, e1, e2):        if isinstance(data, pd.DataFrame):            self.df = data        else:            raise TypeError('Expected data to be a pd.DataFrame')        if not len(set(data.columns.intersection([e1, e2]))) == 2:            raise ValueError('One or more effects (e1, e2) not found in columns of data')        design = data.groupby([e1, e2]).mean()        # design = data.reset_index().pivot(index=e1, columns=e2)        for column in design.columns:            raise NotImplementedError    @staticmethod    def median_polish(data: np.ndarray, max_iterations: int=1, method: str='median'):        """Tukey's median polish method        :param max_iterations: int, maximum number of polish iterations (default 10)        :param method:  str, median or mean (default median), mean would produce a result          equal to a parametric ANOVA        :return: (int, int, int, np.array), row effect, col effect, grand effect, polished          array        """        data = data.copy()        grand_effect = 0        median_row_effects = 0        median_col_effects = 0        row_effects = np.zeros(shape=data.shape[0])        col_effects = np.zeros(shape=data.shape[1])        for i in range(max_iterations):            if method == 'median':                row_medians = np.median(data, 1)                row_effects += row_medians                median_row_effects = np.median(row_effects)            elif method == 'average':                row_medians = np.average(data, 1)                row_effects += row_medians                median_row_effects = np.average(row_effects)            grand_effect += median_row_effects            row_effects -= median_row_effects            data -= row_medians[:, np.newaxis]            if method == 'median':                col_medians = np.median(data, 0)                col_effects += col_medians                median_col_effects = np.median(col_effects)            elif method == 'average':                col_medians = np.average(data, 0)                col_effects += col_medians                median_col_effects = np.average(col_effects)            data -= col_medians            grand_effect += median_col_effects            # terminate polish if no change in row or column effect occurs            if np.abs(np.concatenate([row_effects, col_effects])).sum() == 0:                break        return grand_effect, col_effects, row_effects, data    @staticmethod    def Type3ANOVA(self, data, e1, e2):        """        """class MedianPolish:    """Fits an additive model using Tukey's median polish algorithm"""    def __init__(self, array):        """        :param array:        """        if isinstance(array, np.ndarray):            self.tbl_org = array.astype(float)            self.tbl = self.tbl_org.copy()        else:            raise TypeError('Expected the argument to be a numpy.ndarray.')    def median_polish(self, max_iterations: int=10, method: str='median'):        """Tukey's median polish method        :param max_iterations: int, maximum number of polish iterations (default 10)        :param method:  str, median or mean (default median), mean would produce a result          equal to a parametric ANOVA        :return: (int, int, int, np.array), row effect, col effect, grand effect, polished          array        """        grand_effect = 0        median_row_effects = 0        median_col_effects = 0        row_effects = np.zeros(shape=self.tbl.shape[0])        col_effects = np.zeros(shape=self.tbl.shape[1])        for i in range(max_iterations):            if method == 'median':                row_medians = np.median(self.tbl, 1)                row_effects += row_medians                median_row_effects = np.median(row_effects)            elif method == 'average':                row_medians = np.average(self.tbl, 1)                row_effects += row_medians                median_row_effects = np.average(row_effects)            grand_effect += median_row_effects            row_effects -= median_row_effects            self.tbl -= row_medians[:, np.newaxis]            if method == 'median':                col_medians = np.median(self.tbl, 0)                col_effects += col_medians                median_col_effects = np.median(col_effects)            elif method == 'average':                col_medians = np.average(self.tbl, 0)                col_effects += col_medians                median_col_effects = np.average(col_effects)            self.tbl -= col_medians            grand_effect += median_col_effects        return grand_effect, col_effects, row_effects, self.tbl    def permutation_test(self, n: int=1000, tol: float=1e-3):        """        :param n:        :param tol:        """        raise NotImplementedError